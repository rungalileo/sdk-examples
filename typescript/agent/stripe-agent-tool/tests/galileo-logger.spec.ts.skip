import { GalileoCallbackHandler } from '../src/callbacks/handlers/GalileoCallbackHandler';
import { AgentMetrics } from '../src/types';

// Mock the galileo package
jest.mock('galileo', () => ({
  init: jest.fn().mockResolvedValue(void 0),
  GalileoCallback: jest.fn().mockImplementation(() => ({
    handleLLMStart: jest.fn(),
    handleLLMEnd: jest.fn(),
    handleToolStart: jest.fn(),
    handleToolEnd: jest.fn(),
    handleAgentStart: jest.fn(),
    handleAgentEnd: jest.fn(),
  })),
  flush: jest.fn().mockResolvedValue(void 0),
}));

describe('GalileoCallbackHandler Session Management Tests', () => {
  let galileoHandler: GalileoCallbackHandler;
  let consoleSpy: jest.SpyInstance;
  let mockFlush: jest.MockedFunction<any>;

  beforeEach(async () => {
    // Mock console.log to capture output
    consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    
    // Create a new instance of GalileoCallbackHandler
    galileoHandler = new GalileoCallbackHandler();
    
    // Access the mocked flush function
    const { flush } = require('galileo');
    mockFlush = flush;
  });

  afterEach(() => {
    consoleSpy.mockRestore();
    jest.clearAllMocks();
  });

  describe('Session and Callback Behavior', () => {
    it('should start session without immediately flushing', async () => {
      // Start a session
      await galileoHandler.startSession('test-session-1');
      
      // Verify flush hasn't been called yet
      expect(mockFlush).not.toHaveBeenCalled();
      
      // Verify session started message
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('Session started: test-session-1');
    });

    it('should flush traces when flush is called', async () => {
      // Start a session and simulate some activity
      await galileoHandler.startSession('test-session-2');
      
      galileoHandler.logAgentStart('run-1', { input: 'test input' });
      galileoHandler.logAgentEnd('run-1', { output: 'test output' });
      
      // Call flush
      await galileoHandler.flush();

      // Verify flush was called
      expect(mockFlush).toHaveBeenCalled();
      
      // Verify flush message appeared in console
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('All traces successfully sent to Galileo');
    });

    it('should handle empty queue gracefully', async () => {
      // Call flushBuffered with no queued traces
      await galileoLogger.flushBuffered();

      // Should still call flush and show message
      expect(mockGalileoLoggerInstance.flush).toHaveBeenCalledTimes(1);
      
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 Buffered traces flushed');
    });

    it('should clear queue after flushing', async () => {
      const mockMetrics: AgentMetrics = {
        executionTime: 800,
        success: true,
        toolsUsed: ['list_products']
      };

      // Queue traces
      galileoLogger.queue(mockMetrics, 'Test input', 'Test output');
      
      // Verify queue has content (indirectly by checking internal state)
      expect((galileoLogger as any).pendingTraces).toHaveLength(1);

      // Flush
      await galileoLogger.flushBuffered();

      // Verify queue is cleared
      expect((galileoLogger as any).pendingTraces).toHaveLength(0);
    });

    it('should handle flush errors gracefully', async () => {
      // Mock flush to throw an error
      mockGalileoLoggerInstance.flush.mockRejectedValueOnce(new Error('Network error'));
      
      const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      const mockMetrics: AgentMetrics = {
        executionTime: 500,
        success: false,
        toolsUsed: []
      };

      galileoLogger.queue(mockMetrics, 'Test input', 'Test output');

      // Should not throw error
      await expect(galileoLogger.flushBuffered()).resolves.not.toThrow();

      // Should log error to console
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        'Failed to log to Galileo:',
        expect.any(Error)
      );

      consoleErrorSpy.mockRestore();
    });
  });

  describe('Session Management', () => {
    it('should start session without immediately flushing', async () => {
      const sessionId = await galileoLogger.startSession('Test Session');
      
      expect(sessionId).toBeTruthy();
      expect(mockGalileoLoggerInstance.flush).not.toHaveBeenCalled();
      
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).not.toContain('📊 Buffered traces flushed');
    });

    it('should conclude session with flush', async () => {
      // Start session and queue some traces
      await galileoLogger.startSession('Test Session');
      
      const mockMetrics: AgentMetrics = {
        executionTime: 1200,
        success: true,
        toolsUsed: ['create_customer']
      };
      
      galileoLogger.queue(mockMetrics, 'Create customer', 'Customer created');

      // Conclude session
      await galileoLogger.concludeSession();

      // Should have flushed traces and concluded session
      expect(mockGalileoLoggerInstance.flush).toHaveBeenCalled();
      
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 Session concluded');
    });

    it('should prevent multiple session starts', async () => {
      // Start first session
      const sessionId1 = await galileoLogger.startSession('Session 1');
      
      // Try to start second session - should return same ID
      const sessionId2 = await galileoLogger.startSession('Session 2');
      
      expect(sessionId1).toBe(sessionId2);
    });

    it('should allow new session after conclusion', async () => {
      // Start and conclude first session
      const sessionId1 = await galileoLogger.startSession('Session 1');
      await galileoLogger.concludeSession();
      
      // Start new session
      const sessionId2 = await galileoLogger.startSession('Session 2');
      
      expect(sessionId1).not.toBe(sessionId2);
    });
  });

  describe('Conversation Logging', () => {
    it('should log conversation without flushing', async () => {
      const mockMessages = [
        { role: 'user', content: 'Hello', timestamp: new Date() },
        { role: 'assistant', content: 'Hi there!', timestamp: new Date() },
        { role: 'user', content: 'Show me products', timestamp: new Date() },
        { role: 'assistant', content: 'Here are our products...', timestamp: new Date() }
      ];

      await galileoLogger.logConversation(mockMessages as any);

      // Should not automatically flush
      expect(mockGalileoLoggerInstance.flush).not.toHaveBeenCalled();
      
      // Should log conversation summary
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 4 messages logged to Galileo');
    });

    it('should log satisfaction without auto-flushing', async () => {
      await galileoLogger.logSatisfaction(true);

      // Should not automatically flush
      expect(mockGalileoLoggerInstance.flush).not.toHaveBeenCalled();
      
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 Satisfaction logged: 👍');
    });

    it('should log negative satisfaction correctly', async () => {
      await galileoLogger.logSatisfaction(false);

      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 Satisfaction logged: 👎');
    });
  });

  describe('Integration: Complete Workflow', () => {
    it('should handle complete workflow with single flush at end', async () => {
      // Start session
      const sessionId = await galileoLogger.startSession('Complete Workflow Test');
      expect(sessionId).toBeTruthy();

      // Queue multiple traces (simulating conversation)
      const mockMetrics: AgentMetrics = {
        executionTime: 1000,
        success: true,
        toolsUsed: ['list_products']
      };

      galileoLogger.queue(mockMetrics, 'Hello', 'Hi there!');
      galileoLogger.queue(mockMetrics, 'Show products', 'Here are products...');
      galileoLogger.queue(mockMetrics, 'Create payment link', 'Link created...');

      // Log conversation
      const mockMessages = [
        { role: 'user', content: 'Hello', timestamp: new Date() },
        { role: 'assistant', content: 'Hi there!', timestamp: new Date() }
      ];
      await galileoLogger.logConversation(mockMessages as any);

      // Log satisfaction
      await galileoLogger.logSatisfaction(true);

      // Verify no flush happened during the workflow
      expect(mockGalileoLoggerInstance.flush).not.toHaveBeenCalled();

      // Conclude session (this should trigger flush)
      await galileoLogger.concludeSession();

      // Verify flush happened exactly once during conclusion
      expect(mockGalileoLoggerInstance.flush).toHaveBeenCalled();
      
      // Verify all expected messages
      const capturedOutput = consoleSpy.mock.calls.flat().join(' ');
      expect(capturedOutput).toContain('📊 2 messages logged to Galileo');
      expect(capturedOutput).toContain('📊 Satisfaction logged: 👍');
      expect(capturedOutput).toContain('📊 Buffered traces flushed');
      expect(capturedOutput).toContain('📊 Session concluded');
    });

    it('should handle multiple flush calls correctly', async () => {
      const mockMetrics: AgentMetrics = {
        executionTime: 1000,
        success: true,
        toolsUsed: ['list_products']
      };

      // Queue a trace
      galileoLogger.queue(mockMetrics, 'Test', 'Response');

      // Call flush multiple times
      await galileoLogger.flushBuffered();
      await galileoLogger.flushBuffered();
      await galileoLogger.flushBuffered();

      // Each call should trigger flush (even if queue is empty after first)
      // The first call processes the trace and flushes, subsequent calls just flush
      expect(mockGalileoLoggerInstance.flush).toHaveBeenCalledTimes(4);
      
      // Verify queue is empty after first flush
      expect((galileoLogger as any).pendingTraces).toHaveLength(0);
    });
  });
});
